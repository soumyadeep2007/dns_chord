ID = 0
PROCESS_ID = 1
IP = 2


class Node(process):
    def setup(node_desc, m, predecessor, successor, finger, records):
        self._node_desc = node_desc
        self._m = m
        self._predecessor = predecessor
        self._successor = successor
        self._finger = finger  # 0th entry is blank
        self._records = records

    def run():
        output('{node} is up: pred={p}, succ={s}, finger={f}'
               .format(node=self._node_desc, p=self._predecessor, s=self._successor, f=self._finger))
        await(False)

    def receive(msg=('get', query, client)):
        send(('result', self._records[query['id']]), to=client)
        output(self._node_desc, ' Sent result to: ', client)

    def receive(msg=('find_successor', query)):
        if query['id'] <= self._successor[ID] or query['id'] <= ((1 << self._m) + query['id']):
            node = self._successor
            send(('successor', query, node), to=query['client'])
            output(self._node_desc, ' Sent successor to: ', query['client'])
        else:
            node = self.closest_preceding_node(query['id'])
            send(('find_successor', query), to=node[PROCESS_ID])
            output(self._node_desc, ' Delegated find_successor query to: ', node)

    def closest_preceding_node(id):
        for i in range(self._m - 1, -1, -1):
            if self._finger[i] < id or self._finger[i] < ((1 << self._m) + id):
                return self._finger[i]

    def _in_range(s, e, id):  # id in range (s, e]?
        if id < s:
            id += ((1 << self._m) - 1)
        if e < s:
            e += ((1 << self._m) - 1)
        return (id > s and id <= e)
